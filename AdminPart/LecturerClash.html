<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTMS Admin - Lecturer Clash Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="Styles/lecturerClash.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="Authenticate.js"></script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
</head>

<body>

    <!-- Suggestion Modal -->
    <div id="suggestionModal" class="modal-overlay" style="display:none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Schedule Suggestions</h3>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <p id="modalLecturerName" style="font-weight:bold; margin-bottom:10px;"></p>
                <p style="margin-bottom:10px;">The following section combinations are available and conflict-free:</p>
                <div id="modalSuggestionsList" class="suggestion-list-container"></div>
            </div>
        </div>
    </div>

    <div style="display:flex;">
        <div class="page-container" style="flex:1;">
            <div class="header-section">
                <h1 class="page-title">Lecturer Schedule Clash Analysis</h1>
            </div>

            <!-- Progress Bar -->
            <div class="card-box status-bar" id="scanProgress" style="display:block;">
                <div class="status-text">
                    <span id="scanStatus">Initializing Scan...</span>
                    <span id="scanPercent">0%</span>
                </div>
                <div class="progress-track">
                    <div class="progress-fill" id="scanFill"></div>
                </div>
            </div>

            <!-- Dashboard Charts Container -->
            <div id="clash_charts_container" class="card-box" style="margin-top: 20px; display:none;">
                <div style="display:flex; flex-wrap:wrap; gap:20px;">
                    <div style="flex:1; min-width:300px;">
                        <h4 style="margin-top:0; text-align: center;">Conflict Severity (Lecturers)</h4>
                        <div id="piechart_severity" style="width: 100%; height: 250px;"></div>
                    </div>
                    <div style="flex:1; min-width:300px;">
                        <h4 style="margin-top:0; text-align: center;">Top 5 Clashing Subjects</h4>
                        <div id="barchart_subjects" style="width: 100%; height: 250px;"></div>
                    </div>
                </div>
            </div>

            <!-- Results Table -->
            <div class="card-box" style="margin-top: 20px;">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th style="width: 50px;">NO.</th>
                            <th>LECTURER NAME</th>
                            <th style="width: 120px;">STAFF ID</th>
                            <th style="width: 100px;">SECTIONS</th>
                            <th>SCHEDULE CLASH DETAILS</th>
                            <th style="width: 100px; text-align: center;">SUGGESTIONS</th>
                        </tr>
                    </thead>
                    <tbody id="clashTableBody">
                        <tr class="empty-state">
                            <td colspan="6">
                                Please wait, analyzing all lecturer schedules...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        (function () {
            const localAdminSession = JSON.parse(localStorage.getItem("TTMSFC_adminSession"));
            const API_BASE = "http://web.fc.utm.my/ttms/web_man_webservice_json.cgi";
            let currentSesi = "";
            let currentSem = "";

            const dayMap = { 1: "Sun", 2: "Mon", 3: "Tue", 4: "Wed", 5: "Thu", 6: "Fri", 7: "Sat" };

            function formatTime(masaCode) {
                const startHour = 7 + parseInt(masaCode);
                const endHour = startHour + 1;
                const ampm = h => h >= 12 ? (h > 12 ? h - 12 : h) + "pm" : h + "am";
                return `${ampm(startHour)}-${ampm(endHour)}`;
            }

            async function startClashAnalysis() {
                if (!localAdminSession) { alert("Session expired."); return; }

                $('#scanProgress').show();
                $('#clash_charts_container').hide();
                $('#clashTableBody').html('<tr><td colspan="5" class="empty-state">Initializing...</td></tr>');

                try {
                    // 1. Get Session
                    updateStatus("Fetching session info...", 5);
                    const sesiData = await cachedFetch(`${API_BASE}?entity=sesisemester`);
                    currentSesi = sesiData[0].sesi;
                    currentSem = sesiData[0].semester;
                    // 2. Fetch Master Subject List (for suggestions)
                    updateStatus("Fetching subject sections...", 10);
                    const allSubjects = await cachedFetch(`${API_BASE}?entity=subjek_seksyen&sesi=${currentSesi}&semester=${currentSem}`);

                    const subjectSectionsMap = new Map();
                    allSubjects.forEach(sub => {
                        if (sub.seksyen_list) {
                            if (!subjectSectionsMap.has(sub.kod_subjek)) subjectSectionsMap.set(sub.kod_subjek, []);
                            sub.seksyen_list.forEach(sec => {
                                subjectSectionsMap.get(sub.kod_subjek).push({
                                    kod_subjek: sub.kod_subjek,
                                    nama_subjek: sub.nama_subjek,
                                    seksyen: sec.seksyen,
                                    key: `${sub.kod_subjek}-${sec.seksyen}`
                                });
                            });
                        }
                    });

                    // 3. Fetch Bulk Timetable
                    updateStatus("Fetching timetable data...", 10);
                    const bulkTimetable = await cachedFetch(`${API_BASE}?entity=jadual_subjek&sesi=${currentSesi}&semester=${currentSem}`);

                    // Build section-to-times map
                    const sectionTimeMap = new Map();
                    if (Array.isArray(bulkTimetable)) {
                        bulkTimetable.forEach(slot => {
                            if (!slot.hari || !slot.masa || !slot.kod_subjek || !slot.seksyen) return;
                            const secKey = `${slot.kod_subjek}-${slot.seksyen}`;
                            if (!sectionTimeMap.has(secKey)) sectionTimeMap.set(secKey, []);
                            sectionTimeMap.get(secKey).push({
                                day: slot.hari,
                                time: slot.masa,
                                key: `${slot.hari}-${slot.masa}`,
                                prettyTime: `${dayMap[slot.hari] || 'Day' + slot.hari} ${formatTime(slot.masa)}`
                            });
                        });
                    }
                    console.log(`Built timetable index with ${sectionTimeMap.size} sections`);

                    // 3. Fetch Lecturer List
                    updateStatus("Fetching lecturer list...", 20);
                    const lecturerList = await cachedFetch(`${API_BASE}?entity=pensyarah&session_id=${localAdminSession.session_id}&sesi=${currentSesi}&semester=${currentSem}`);

                    if (!Array.isArray(lecturerList)) {
                        throw new Error("Failed to fetch lecturer list");
                    }

                    // Filter to lecturers with 2+ sections (only they can have clashes)
                    const lecturersWithMultipleSections = lecturerList.filter(l => (l.bil_seksyen || 0) >= 2);
                    console.log(`${lecturersWithMultipleSections.length} lecturers have 2+ sections (potential clashes)`);

                    // 4. Analyze Each Lecturer's Schedule
                    const clashReport = [];
                    const batchSize = 30;
                    let processedCount = 0;

                    for (let i = 0; i < lecturersWithMultipleSections.length; i += batchSize) {
                        const batch = lecturersWithMultipleSections.slice(i, i + batchSize);

                        // Fetch subjects for all lecturers in this batch in parallel
                        const batchResults = await Promise.all(
                            batch.map(lecturer =>
                                cachedFetch(`${API_BASE}?entity=pensyarah_subjek&no_pekerja=${lecturer.no_pekerja}`)
                                    .then(subjects => ({ lecturer, subjects }))
                                    .catch(() => ({ lecturer, subjects: [] }))
                            )
                        );

                        // Process each lecturer's results
                        batchResults.forEach(({ lecturer, subjects }) => {
                            if (!Array.isArray(subjects)) return;

                            // Filter to current semester subjects only
                            const currentSubjects = subjects.filter(
                                s => s.sesi === currentSesi && s.semester == currentSem
                            );

                            if (currentSubjects.length < 2) return;

                            // Include raw sections for suggestion engine
                            const rawSections = currentSubjects.map(sub => ({
                                kod_subjek: sub.kod_subjek,
                                nama_subjek: sub.nama_subjek,
                                seksyen: sub.seksyen,
                                key: `${sub.kod_subjek}-${sub.seksyen}`
                            }));

                            // Build this lecturer's time slots
                            const lecturerSlots = [];
                            currentSubjects.forEach(sub => {
                                const secKey = `${sub.kod_subjek}-${sub.seksyen}`;
                                const times = sectionTimeMap.get(secKey) || [];
                                times.forEach(t => {
                                    lecturerSlots.push({
                                        secKey,
                                        kod_subjek: sub.kod_subjek,
                                        nama_subjek: sub.nama_subjek,
                                        seksyen: sub.seksyen,
                                        ...t
                                    });
                                });
                            });

                            // Detect clashes (same day+time slot)
                            const clashes = [];
                            const uniqueClashes = new Set();

                            for (let a = 0; a < lecturerSlots.length; a++) {
                                for (let b = a + 1; b < lecturerSlots.length; b++) {
                                    const slotA = lecturerSlots[a];
                                    const slotB = lecturerSlots[b];

                                    if (slotA.key === slotB.key && slotA.secKey !== slotB.secKey) {
                                        const clashId = [slotA.secKey, slotB.secKey].sort().join(" vs ");
                                        if (!uniqueClashes.has(clashId)) {
                                            uniqueClashes.add(clashId);
                                            clashes.push({
                                                subject1: slotA.secKey,
                                                subject1Name: slotA.nama_subjek,
                                                subject2: slotB.secKey,
                                                subject2Name: slotB.nama_subjek,
                                                time: slotA.prettyTime
                                            });
                                        }
                                    }
                                }
                            }

                            if (clashes.length > 0) {
                                clashReport.push({
                                    lecturer: {
                                        nama: lecturer.nama,
                                        no_pekerja: lecturer.no_pekerja
                                    },
                                    clashes,
                                    sectionCount: currentSubjects.length,
                                    rawSections, // For suggestions
                                    suggestions: []
                                });
                            }
                        });

                        processedCount += batch.length;
                        const pct = 20 + Math.round((processedCount / lecturersWithMultipleSections.length) * 70);
                        updateStatus(`Analyzing schedules... (${processedCount}/${lecturersWithMultipleSections.length})`, pct);
                    }

                    console.log(`Found ${clashReport.length} lecturers with clashes`);

                    // Generate suggestions for all clashes
                    updateStatus("Generating suggestions...", 95);
                    clashReport.forEach(item => {
                        const clashingSubjects = new Set();
                        item.clashes.forEach(c => {
                            clashingSubjects.add(c.subject1.split('-')[0]);
                            clashingSubjects.add(c.subject2.split('-')[0]);
                        });
                        item.suggestions = generateSuggestions(
                            item.rawSections,
                            clashingSubjects,
                            subjectSectionsMap,
                            sectionTimeMap
                        );
                    });

                    // 5. Render Results
                    updateStatus("Done!", 100);
                    renderTable(clashReport);
                    drawClashCharts(clashReport);

                } catch (err) {
                    console.error(err);
                    alert("Error during scan: " + err.message);
                    updateStatus("Error: " + err.message, 0);
                }
            }

            // --- Google Charts ---
            let isGoogleChartsLoaded = false;
            let pendingClashReport = null;

            if (typeof google !== 'undefined') {
                google.charts.load('current', { 'packages': ['corechart', 'bar'] });
                google.charts.setOnLoadCallback(() => {
                    isGoogleChartsLoaded = true;
                    if (pendingClashReport) {
                        drawClashCharts(pendingClashReport);
                    }
                });
            }

            function drawClashCharts(report) {
                if (!isGoogleChartsLoaded) {
                    pendingClashReport = report;
                    return;
                }

                if (report.length === 0) return;

                $('#clash_charts_container').show();

                // Pie Chart - Severity
                let s1 = 0, s2 = 0, s3 = 0;
                report.forEach(r => {
                    const c = r.clashes.length;
                    if (c === 1) s1++;
                    else if (c === 2) s2++;
                    else if (c >= 3) s3++;
                });

                const pieData = google.visualization.arrayToDataTable([
                    ['Severity', 'Count'],
                    ['1 Conflict', s1],
                    ['2 Conflicts', s2],
                    ['3+ Conflicts', s3]
                ]);

                const pieOptions = {
                    fontName: 'Inter',
                    pieHole: 0.6,
                    colors: ['#fbc02d', '#f57c00', '#d32f2f'],
                    chartArea: { left: 20, width: '100%', height: '80%' },
                    legend: { position: 'right', textStyle: { color: '#374151', fontSize: 13 } },
                    animation: { startup: true, duration: 1000, easing: 'out' }
                };

                const pieChart = new google.visualization.PieChart(document.getElementById('piechart_severity'));
                pieChart.draw(pieData, pieOptions);

                // Bar Chart - Top Subjects
                const subjCount = {};
                report.forEach(r => {
                    r.clashes.forEach(c => {
                        const code1 = c.subject1.split('-')[0];
                        const code2 = c.subject2.split('-')[0];
                        subjCount[code1] = (subjCount[code1] || 0) + 1;
                        subjCount[code2] = (subjCount[code2] || 0) + 1;
                    });
                });

                const sortedSubj = Object.entries(subjCount)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);

                const barArray = [['Subject', 'Conflicts']];
                sortedSubj.forEach((item) => {
                    barArray.push([item[0], item[1]]);
                });

                const barData = google.visualization.arrayToDataTable(barArray);
                const barOptions = {
                    fontName: 'Inter',
                    legend: { position: "none" },
                    chartArea: { width: '60%', height: '70%', left: '30%' },
                    colors: ['#3b82f6'],
                    hAxis: { minValue: 0, format: '0', gridlines: { color: '#f3f4f6' } },
                    vAxis: { textStyle: { color: '#374151', bold: true } },
                    animation: { startup: true, duration: 1200, easing: 'out' },
                    bar: { groupWidth: '65%' }
                };

                const barChart = new google.visualization.BarChart(document.getElementById('barchart_subjects'));
                barChart.draw(barData, barOptions);
            }

            function renderTable(report) {
                const tbody = $('#clashTableBody');
                tbody.empty();

                if (report.length === 0) {
                    tbody.html('<tr class="empty-state"><td colspan="6">No clashes detected! All lecturers have conflict-free schedules.</td></tr>');
                    return;
                }

                // Sort by Name
                const sortedReport = [...report].sort((a, b) => a.lecturer.nama.localeCompare(b.lecturer.nama));

                sortedReport.forEach((item, idx) => {
                    const l = item.lecturer;

                    const detailsHtml = item.clashes.map(c => `
                        <div class="clash-detail">
                            <strong>${c.subject1}</strong> : <strong>${c.subject2}</strong> 
                            <span style="color:#b91c1c;">(${c.time})</span>
                        </div>
                    `).join("");

                    const suggCount = item.suggestions ? item.suggestions.length : 0;
                    const suggHtml = suggCount > 0
                        ? `<a class="suggestion-link" data-idx="${idx}">${suggCount}</a>`
                        : `<span class="suggestion-link zero">0</span>`;

                    const row = `
                        <tr>
                            <td>${idx + 1}.</td>
                            <td>
                                <div style="font-weight:600;">${l.nama}</div>
                            </td>
                            <td><span class="badge badge-faculty">${l.no_pekerja || '-'}</span></td>
                            <td style="text-align:center;">${item.sectionCount}</td>
                            <td class="clash-row">${detailsHtml}</td>
                            <td style="text-align:center;">${suggHtml}</td>
                        </tr>
                    `;
                    tbody.append(row);
                });

                // Bind Suggestion Clicks
                $('.suggestion-link:not(.zero)').off('click').on('click', function () {
                    const idx = $(this).data('idx');
                    showSuggestions(sortedReport[idx]);
                });

                $('#scanStatus').text(`Scan Complete. Found ${report.length} lecturers with schedule conflicts.`);
            }

            function renderEmpty(msg) {
                $('#clashTableBody').html(`<tr class="empty-state"><td colspan="5">${msg}</td></tr>`);
                updateStatus("Completed", 100);
            }

            function updateStatus(msg, percent) {
                $('#scanStatus').text(msg);
                $('#scanPercent').text(percent + "%");
                $('#scanFill').css('width', percent + "%");
            }

            // --- Suggestion Algorithm ---
            function generateSuggestions(currentSections, clashingSubjectCodes, subjectSectionsMap, sectionTimeMap) {
                if (!Array.isArray(currentSections)) {
                    console.error("generateSuggestions: currentSections is not an array", currentSections);
                    return [];
                }

                const solutions = [];
                const solutionsKeys = new Set();
                const problemSubjects = Array.from(clashingSubjectCodes);

                function hasClash(testSections) {
                    for (let a = 0; a < testSections.length; a++) {
                        for (let b = a + 1; b < testSections.length; b++) {
                            const sA = testSections[a];
                            const sB = testSections[b];
                            if (sA.key === sB.key) continue;

                            const tA = sectionTimeMap.get(sA.key) || [];
                            const tB = sectionTimeMap.get(sB.key) || [];
                            for (const timeA of tA) {
                                for (const timeB of tB) {
                                    if (timeA.key === timeB.key) return true;
                                }
                            }
                        }
                    }
                    return false;
                }

                problemSubjects.forEach(pCode => {
                    // Defensive check
                    if (!pCode) return;

                    // Find ALL indices for this subject code
                    const indices = [];
                    currentSections.forEach((s, idx) => {
                        if (s.kod_subjek === pCode) indices.push(idx);
                    });

                    if (indices.length === 0) {
                        console.warn("Could not find subject code in current sections:", pCode);
                        return;
                    }

                    indices.forEach(currentSecIndex => {
                        const originalSec = currentSections[currentSecIndex];
                        const alternatives = subjectSectionsMap.get(pCode) || [];

                        alternatives.forEach(altSec => {
                            // Skip if it's the exact same section
                            if (altSec.seksyen === originalSec.seksyen) return;

                            // Skip if we are ALREADY teaching this alternative section (duplicate enrollment)
                            const alreadyTeaching = currentSections.some(s => s.key === altSec.key);
                            if (alreadyTeaching) return;

                            const trialSchedule = [...currentSections];
                            trialSchedule[currentSecIndex] = altSec;

                            if (!hasClash(trialSchedule)) {
                                const solKey = trialSchedule.map(s => s.key).sort().join("|");
                                if (!solutionsKeys.has(solKey)) {
                                    solutionsKeys.add(solKey);
                                    solutions.push({
                                        schedule: trialSchedule,
                                        changedSubj: pCode,
                                        newSection: altSec,
                                        oldSection: originalSec
                                    });
                                }
                            }
                        });
                    });
                });

                return solutions;
            }

            function showSuggestions(item) {
                $('#modalLecturerName').text(`Suggested Plans for ${item.lecturer.nama}`);
                const list = $('#modalSuggestionsList');
                list.empty();

                if (!item.suggestions || item.suggestions.length === 0) {
                    list.html('<p>No conflict-free alternative sections found.</p>');
                } else {
                    item.suggestions.forEach((sol, i) => {
                        const oldSec = sol.oldSection ? sol.oldSection.seksyen : '?';
                        const newSec = sol.newSection.seksyen;
                        const code = sol.changedSubj;

                        list.append(`
                            <div class="suggestion-item">
                                <strong>Option ${i + 1}:</strong> 
                                <span>Switch <strong style="color:#b91c1c;">${code}-${oldSec}</strong> to <strong style="color:#15803d;">${code}-${newSec}</strong></span>
                            </div>
                        `);
                    });
                }
                $('#suggestionModal').css('display', 'flex');
                $('body').addClass('modal-open');
            }

            window.closeModal = function () {
                $('#suggestionModal').hide();
                $('body').removeClass('modal-open');
            }

            $(document).ready(function () {
                startClashAnalysis();
            });

        })();
    </script>
</body>

</html>